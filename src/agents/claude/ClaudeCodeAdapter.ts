import { Agent, AgentExecutionRequest } from '../base/Agent.js';
import { AgentResult, AgentType } from '../../types/agent.js';
import fs from 'fs-extra';
import { execa } from 'execa';
import path from 'path';

export class ClaudeCodeAdapter extends Agent {
  readonly type = AgentType.CLAUDE;

  async execute(request: AgentExecutionRequest): Promise<AgentResult> {
    const startTime = Date.now();
    const instructionFile = `/tmp/claude-instruction-${request.subtaskId}.md`;

    // 1. Prepare Instruction File
    const prompt = this.buildPrompt(request);
    await fs.writeFile(instructionFile, prompt);

    try {
      // Log the prompt for debugging
      console.log(`[Claude] Full Prompt:\n${prompt}`);
      
      console.log(`[Claude] Executing headless mode for subtask ${request.subtaskId}...`);
      
      // FIXME: Replace with actual CLI call when available
      // const { stdout } = await execa('claude-code', ['--headless', '--input', instructionFile, '--output', request.outputFile]);
      
      // MOCK BEHAVIOR for now
      await this.mockExecution(request);

      // 3. Verify Output
      if (!await fs.pathExists(request.outputFile)) {
        throw new Error(`Output file not created: ${request.outputFile}`);
      }

      // 4. Parse Result (Simplified)
      // In reality, we would parse frontmatter for tokensUsed
      const tokensUsed = 1000; // Mock

      return {
        subtaskId: request.subtaskId,
        agent: this.type,
        status: 'success',
        outputFile: request.outputFile,
        tokensUsed,
        executionTimeMs: Date.now() - startTime
      };

    } catch (error: any) {
      return {
        subtaskId: request.subtaskId,
        agent: this.type,
        status: 'failure',
        outputFile: request.outputFile,
        tokensUsed: 0,
        executionTimeMs: Date.now() - startTime,
        error: error.message
      };
    } finally {
      // Cleanup
      await fs.remove(instructionFile).catch(() => {});
    }
  }

  private buildPrompt(request: AgentExecutionRequest): string {
    return `
# Task for Claude Code

## Context Files
${request.contextFiles.map(f => `- ${f}`).join('\n')}

## Instruction
${request.taskDescription}

## Output Requirement
Save your response to: ${request.outputFile}
Format as Markdown with Frontmatter.
`;
  }

  private async mockExecution(request: AgentExecutionRequest): Promise<void> {
    await this.applySimpleActions(request);

    const mockContent = `---
agent: claude-code
subtask_id: ${request.subtaskId}
status: success
tokens_used: 1234
---

# Result for ${request.subtaskId}

This is a mock result generated by ClaudeCodeAdapter.
Task: ${request.taskDescription}
`;
    await fs.ensureDir(path.dirname(request.outputFile));
    await fs.writeFile(request.outputFile, mockContent);
    await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate delay
  }

  private async applySimpleActions(request: AgentExecutionRequest): Promise<void> {
    const normalized = request.taskDescription.toLowerCase();
    
    const englishMatch = normalized.match(/(?:create|make|add)\s+(?:a\s+)?([\w\-\/]+)\s+(?:folder|directory)/);
    const koreanSuffixMatch = request.taskDescription.match(/([\w\-\/]+)\s*폴더/);
    
    const folderName = englishMatch?.[1] || koreanSuffixMatch?.[1];
    if (folderName) {
      const safeName = folderName.replace(/[^A-Za-z0-9_\-\/]/g, '');
      if (safeName.length > 0) {
        const folderPath = path.resolve(process.cwd(), safeName);
        await fs.ensureDir(folderPath);
        console.log(`[ClaudeMock] Created folder: ${folderPath}`);
      }
    }
  }
}
